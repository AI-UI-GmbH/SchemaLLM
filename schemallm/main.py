import json
import logging
from typing import Callable, List, Union, Dict, Any

from transformers import PreTrainedModel, PreTrainedTokenizer

from .contraints import generate_number, generate_string, generate_literal, ConstrainedOutput

GENERATION_MARKER = "|GENERATION|"
PROPMT_TEMPLATE = """{prompt}\nOutput result in JSON format\nResult: {progress}"""


def retry(func: Callable, temperature, max_attemps: int = 3, *args, **kwargs) -> ConstrainedOutput:
    """
    Args:
        func: functions to call
        temperature:
        max_attemps:
    """
    attempts = 0
    while attempts < max_attemps:
        try:
            return func(*args, temperature=temperature, **kwargs)
        except Exception as e:
            print(e)
            temperature *= 1.3
            temperature = max(1, temperature)
            attempts += 1
    raise ValueError("Failed to generate a valid number")


def build_prompt(base_prompt: str, obj: Union[dict, list]):
    """
    Args:
        base_prompt: prompt from user
        obj: object being built
    """
    progress = json.dumps(obj)
    gen_marker_index = progress.find(f'"{GENERATION_MARKER}"')
    if gen_marker_index != -1:
        progress = progress[:gen_marker_index]
    else:
        raise ValueError("Failed to find generation marker")

    prompt = PROPMT_TEMPLATE.format(
        prompt=base_prompt,
        progress=progress,
    )

    return prompt


class SchemaLLM:
    def __init__(
        self,
        model: PreTrainedModel,
        tokenizer: PreTrainedTokenizer,
        *,
        max_array_length: int = 10,
        max_number_tokens: int = 6,
        temperature: float = 1.0,
        max_string_token_length: int = 10,
    ):
        """
        Args:
            model:
            tokenizer:
            max_array_length:
            max_number_tokens:
            temperature:
            max_string_token_length:
        """
        self.model = model
        self.tokenizer = tokenizer

        self.max_array_length = max_array_length

        self.max_number_tokens = max_number_tokens
        self.temperature = temperature
        self.max_string_token_length = max_string_token_length

    def generate(
        self,
        schema: Dict[str, Any],
        prompt: str,
    ) -> dict:
        """
        Args:
            schema: generated by pydanicBaseModel.schema()
            prompt:
        """
        self.value = {}
        self.prompt = prompt
        self.definitions = schema.get("definitions", {})
        generated_data: ConstrainedOutput = self.generate_object(schema, self.value)
        return generated_data.value

    def add_generate_marker(
        self,
        schema_type: str,
        obj: Union[dict, list],
        key: Union[str, None] = None,
    ):
        """
        Args:
            schema:
            obj:
            key:
        """
        # str, int, float, bool, typing.Literal
        if schema_type in ("string", "integer", "boolean", "number"):
            generation_marker = GENERATION_MARKER
        # BaseModel
        elif schema_type == "object":
            generation_marker = {}
        # List, Tuple
        elif schema_type == "array":
            generation_marker = []
        else:
            raise Exception("unsupported type: " + schema_type)

        if isinstance(obj, (list, tuple)):
            obj.append(generation_marker)
        elif isinstance(obj, dict):
            assert key
            obj[key] = generation_marker

    def generate_value(
        self,
        schema: Dict[str, Any],
        obj: Union[dict, list],
    ) -> ConstrainedOutput:
        """
        Args:
            schema:
            obj:
        """
        schema_type = schema.get("type")
        # check Literal first
        if "enum" in schema:
            return self.generate_literal(schema=schema)
        # int, float
        elif schema_type in ("integer", "number"):
            return self.generate_number(schema=schema)
        # bool
        elif schema_type == "boolean":
            return self.generate_boolean()
        # str
        elif schema_type == "string":
            return self.generate_string()
        # BaseModel
        elif schema_type == "object":
            return self.generate_object(schema=schema, obj=obj)
        # typing.List, typing.Tuple
        elif schema_type == "array":
            return self.generate_array(schema=schema, obj=obj)
        raise ValueError(f"Unsupported schema type: {schema_type}")

    def generate_number(self, schema: Dict[str, Any]) -> ConstrainedOutput:
        """
        Args:
            schema:
        """
        prompt = build_prompt(base_prompt=self.prompt, obj=self.value)
        logging.debug("[generate_number] " + prompt)
        output = retry(
            temperature=self.temperature,
            max_attemps=3,
            func=generate_number,
            type_=int if schema["type"] == "integer" else float,
            tokenizer=self.tokenizer,
            model=self.model,
            prompt=prompt,
            max_number_tokens=self.max_number_tokens,
        )
        return output

    def generate_boolean(self) -> ConstrainedOutput:
        """ """
        prompt = build_prompt(base_prompt=self.prompt, obj=self.value)
        logging.debug("[generate_boolean] " + prompt)
        # use true/false here because it is json format
        output = generate_literal(prompt=prompt, values=["true", "false"], tokenizer=self.tokenizer, model=self.model)
        # convert str to bool
        output.value = output.value == "true"
        return output

    def generate_string(self) -> ConstrainedOutput:
        """ """
        prompt = build_prompt(base_prompt=self.prompt, obj=self.value)
        prompt += '"'
        logging.debug("[generate_string] " + prompt)
        output = retry(
            temperature=self.temperature,
            max_attemps=3,
            func=generate_string,
            prompt=prompt,
            tokenizer=self.tokenizer,
            model=self.model,
            max_string_token_length=self.max_string_token_length,
        )
        return output

    def generate_literal(self, schema: Dict[str, Any]) -> ConstrainedOutput:
        """
        Args:
            schema:
            obj:
        """
        prompt = build_prompt(base_prompt=self.prompt, obj=self.value)
        prompt += '"'
        values = schema["enum"]
        logging.debug("[generate_literal] " + prompt)
        logging.debug("[generate_literal values] " + json.dumps(values))
        output = generate_literal(
            prompt=prompt, values=values, tokenizer=self.tokenizer, model=self.model, temperature=self.temperature
        )
        return output

    def generate_object(self, schema: Dict[str, Any], obj: Dict[str, Any]) -> ConstrainedOutput:
        """
        Args:
            schema:
            obj:
        """
        for key, subschema in schema["properties"].items():
            logging.debug("[generate_object] generating value for " + key)

            # check reference
            if "$ref" in subschema:
                definition_key = subschema["$ref"].replace("#/definitions/", "")
                subschema = self.definitions[definition_key]

            self.add_generate_marker(schema_type=subschema["type"], obj=obj, key=key)
            logging.debug("[generate_object] current schema " + json.dumps(subschema))
            logging.debug("[generate_object] tmp object " + json.dumps(obj))
            output: ConstrainedOutput = self.generate_value(schema=subschema, obj=obj[key])
            obj[key] = output.value
        return ConstrainedOutput(value=obj)

    def generate_array(self, schema: Dict[str, Any], obj: List[Any]) -> ConstrainedOutput:
        """
        generate for array and tuple

        Args:
            schema:
                class Schema:
                    title: str
                    type: 'array'
                    minItems: Optional[int]
                    maxItems: Optional[int]
                    items: Optional[List[{'type': 'string'}]]]
            obj:
        """
        logging.debug("[generate_array] generating array")
        min_items = schema.get("min_items", 1)
        max_items = schema.get("max_items", self.max_array_length)
        items = schema["items"]
        for i in range(max_items):
            if isinstance(items, dict):
                subschema = items
            elif isinstance(items, list):
                if i < len(items):
                    subschema = items[i]
                else:
                    subschema = items[0]
            else:
                raise Exception(f"Unknown item schema: {items}")

            # check reference
            if "$ref" in subschema:
                definition_key = subschema["$ref"].replace("#/definitions/", "")
                subschema = self.definitions[definition_key]

            # add marker
            self.add_generate_marker(schema_type=subschema["type"], obj=obj)
            # generate
            output: ConstrainedOutput = self.generate_value(schema=subschema, obj=obj)
            obj[-1] = output.value

            if output.array_closed and len(obj) >= min_items:
                break
        return ConstrainedOutput(value=obj)
